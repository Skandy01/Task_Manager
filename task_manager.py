# -*- coding: utf-8 -*-
"""Task Manager.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yEePNwFIgUe_fzX48kadJfQV0BeKJOoB

# Personalized Task Manager

#### Agenda
- Develop a personalized task manager in Python
- Create a user-friendly interface for task management
- Implement functionalities for adding, editing, and removing tasks
- Include features for saving and loading tasks from a file
- Ensure data integrity and reliability in task management operations
- Incorporate additional features such as task prioritization and due dates
- Focus on code readability, modularity, and scalability
- Accommodate diverse user requirements for effective task management

1. **Set up the project directory:**<br>
Create a new directory for the project, e.g., "task_manager", to organize files.
2. **Initialize a Python script:**<br>
Create a new Python file, e.g., "task_manager.py", for writing code.
3. **Import necessary modules:**<br>
Import required modules like "os" for file handling.<br>
The `os` module in Python provides functions for interacting with the operating system, including file and directory manipulation, process management, and environment variables access.
4. **Define the TaskManager class:**<br>
Create a class to manage tasks, with attributes like directory and tasks.
5. **Define methods for task management:**<br>
Inside the TaskManager class, define methods to add, edit, omit, save, and load tasks.
6. **Implement the methods:**<br>
Fill in the method bodies with the appropriate code to perform each task management operation. For example, adding a task would involve updating the tasks dictionary with the new task information.
   1. **add_task**: Update tasks dictionary with task name as key and description as value, if task doesn't exist.
   2. **edit_task**: Modify task description for given task name if it exists in tasks dictionary.
   3. **omit_task**: Delete task entry for given task name if it exists in tasks dictionary.
   4. **save_tasks**: Write tasks dictionary contents to a file in specified directory.
   5. **exit**: To terminate the program's execution and return control to the operating system or calling process.
"""

import os  # Import the os module for file and directory operations

class TaskManager:
    def __init__(self, directory):
        self.directory = directory  # Initialize the directory for storing tasks
        self.tasks = {}  # Initialize an empty dictionary to store tasks

    def add_task(self, task_name, task_description):
        if task_name not in self.tasks:  # Check if the task already exists
            self.tasks[task_name] = task_description  # Add the task to the tasks dictionary
            print(f"Task '{task_name}' added successfully.")
        else:
            print(f"Task '{task_name}' already exists.")  # Print message if task already exists

    def edit_task(self, task_name, new_task_description):
        if task_name in self.tasks:  # Check if the task exists
            self.tasks[task_name] = new_task_description  # Update the task description
            print(f"Task '{task_name}' edited successfully.")
        else:
            print(f"Task '{task_name}' does not exist.")  # Print message if task does not exist

    def omit_task(self, task_name):
        if task_name in self.tasks:  # Check if the task exists
            del self.tasks[task_name]  # Delete the task from the tasks dictionary
            print(f"Task '{task_name}' omitted successfully.")
        else:
            print(f"Task '{task_name}' does not exist.")  # Print message if task does not exist

    def save_tasks(self):
        with open(os.path.join(self.directory, 'tasks.txt'), 'w') as file:  # Open file for writing
            for task_name, task_description in self.tasks.items():  # Iterate over tasks dictionary
                file.write(f"{task_name}: {task_description}\n")  # Write task name and description to file
        print("Tasks saved successfully.")  # Print confirmation message

    def load_tasks(self):
        file_path = os.path.join(self.directory, 'tasks.txt')  # Construct file path for tasks file
        if os.path.exists(file_path):  # Check if tasks file exists
            with open(file_path, 'r') as file:  # Open file for reading
                for line in file:  # Iterate over each line in the file
                    task_name, task_description = line.strip().split(': ')  # Split line into task name and description
                    self.tasks[task_name] = task_description  # Add task to tasks dictionary
            print("Tasks loaded successfully.")  # Print confirmation message
        else:
            print("No previous tasks found.")  # Print message if no tasks file exists

"""7.  Create a directory named "task_manager_data" if it doesn't exist to store tasks and ensure organizational structure."""

# Create directory for storing tasks if it doesn't exist
if not os.path.exists('task_manager_data'):  # Check if directory exists
    os.makedirs('task_manager_data')  # Create directory if it does not exist

"""8. **Main Program Entry**:
Check if the script is being run as the main program.
9. **Task Manager Initialization**:
Create an instance of the `TaskManager` class with the directory specified as "task_manager_data".
10. **Load Tasks**:
Call the `load_tasks()` method to load previously saved tasks from the file.
11. **User Interaction Loop**:
Enter a loop to interactively manage tasks until the user chooses to exit.
12. **Display Menu Options**:
Print a menu displaying options for adding, editing, omitting, saving tasks, or exiting.
13. **Prompt User Input**:
Ask the user to input their choice from the displayed menu (1-5).
14. **Process User Choice**:
Based on the user's input, execute the corresponding action.
   - If the choice is '1', prompt for task name and description, then add the task.
   - If the choice is '2', prompt for task name and new description, then edit the task.
   - If the choice is '3', prompt for task name, then omit (delete) the task.
   - If the choice is '4', save the current tasks to the file.
   - If the choice is '5', print "Exiting..." and break out of the loop to end the program.
"""

# Example usage
if __name__ == "__main__":
    task_manager = TaskManager('task_manager_data')  # Create instance of TaskManager
    task_manager.load_tasks()  # Load tasks from file

    while True:
        print("\n1. Add Task")
        print("2. Edit Task")
        print("3. Omit Task")
        print("4. Save Tasks")
        print("5. Exit")
        choice = input("Enter your choice (1-5): ")  # Prompt user for choice

        if choice == '1':
            task_name = input("Enter task name: ")  # Prompt user for task name
            task_description = input("Enter task description: ")  # Prompt user for task description
            task_manager.add_task(task_name, task_description)  # Call add_task method
        elif choice == '2':
            task_name = input("Enter task name to edit: ")  # Prompt user for task name to edit
            new_task_description = input("Enter new task description: ")  # Prompt user for new task description
            task_manager.edit_task(task_name, new_task_description)  # Call edit_task method
        elif choice == '3':
            task_name = input("Enter task name to omit: ")  # Prompt user for task name to omit
            task_manager.omit_task(task_name)  # Call omit_task method
        elif choice == '4':
            task_manager.save_tasks()  # Call save_tasks method
        elif choice == '5':
            print("Exiting...")  # Print message indicating program exit
            break  # Exit the loop and end the program
        else:
            print("Invalid choice. Please enter a number between 1 and 5.")  # Print message for invalid choice

